

# Manejo de memoria en windows

Para este caso usaremos [https://github.com/PacktPublishing/Malware-Development-for-Ethical-Hackers/tree/main/chapter01/01-whatis-malware-dev](https://github.com/PacktPublishing/Malware-Development-for-Ethical-Hackers/tree/main/chapter01/01-whatis-malware-dev)

- **`VirtualAlloc`:** Reserva un bloque de memoria en el espacio de direcciones del proceso.
- **`RtlMoveMemory`:** Copia el contenido del payload al espacio de memoria reservado.
- **`VirtualProtect`:** Cambia las protecciones de la memoria asignada para permitir la ejecución.
- **`CreateThread`:** Crea un hilo en el proceso que ejecuta el payload almacenado en memoria.
- **`WaitForSingleObject`:** Espera a que el hilo recién creado termine su ejecución.


## Ejercicios básicos de manejo de memoria y ejecución en Windows:

1. **Ejercicio 1:** Escribe un programa que utilice `VirtualAlloc` para asignar un bloque de memoria de 1 KB y luego lo libere utilizando `VirtualFree`.
    
2. **Ejercicio 2:** Implementa un programa que use `VirtualProtect` para cambiar las protecciones de un bloque de memoria de solo lectura a lectura-escritura.
    
3. **Ejercicio 3:** Crea una función que utilice `RtlMoveMemory` para copiar un array de bytes a otro lugar en la memoria y luego imprime ambos arrays para verificar que el contenido sea el mismo.
    
4. **Ejercicio 4:** Modifica el código para que, en lugar de ejecutar un payload, se llame a una función simple que imprima "Hello, World!" utilizando `CreateThread`.
    
5. **Ejercicio 5:** Reemplaza el payload actual con uno que simplemente muestre un mensaje mediante `MessageBox` para entender cómo se carga y ejecuta el payload en memoria.
    


### 1.Asignar_memoria-VirtualAlloc.c

```c
#include <windows.h>
#include <stdio.h>

int main()
{

    void* memory = VirtualAlloc(NULL,1024, MEM_COMMIT| MEM_RESERVE, PAGE_READWRITE);

    if (memory==NULL){

        printf("Error al asignar memoria\n");
        return 1;
    }
    else{

        printf("Memoria asignada exitosamente\n");
    }

    if (VirtualFree(memory,0,MEM_RELEASE))    {

        printf("Memoria liberada exitosamente\n");
    }
    else{

        printf("Error al liberar memoria\n");
    }

return 0;

}
```

```c

void* memory = VirtualAlloc(NULL, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

```

Aquí se está utilizando la función VirtualAlloc, que es parte de la API de Windows y se usa para asignar memoria virtual.

NULL: Indica que Windows elegirá la dirección de memoria donde se asignará el bloque.
1024: Especifica el tamaño del bloque de memoria a asignar (1 KB).
MEM_COMMIT | MEM_RESERVE: Son banderas que especifican cómo se asignará la memoria:
MEM_COMMIT: Reserva y asigna físicamente la memoria.
MEM_RESERVE: Reserva el espacio de direcciones virtuales sin asignar memoria física.
PAGE_READWRITE: Especifica los permisos de la memoria asignada. Aquí se permite leer y escribir en esa memoria.

```c
if (VirtualFree(memory, 0, MEM_RELEASE)) { 
...
}

```
Después de usar la memoria, el programa la libera con VirtualFree:

memory: Es la dirección de memoria asignada previamente.
0: En este caso, se ignora el tamaño porque estamos liberando toda la región de memoria.
MEM_RELEASE: Bandera que indica que la memoria se libera completamente.

Si VirtualFree devuelve un valor distinto de cero, significa que la memoria se ha liberado exitosamente, y se imprime un mensaje de éxito. Si no, se imprime un mensaje de error.

### 2.Proteccion_de_memoria-VirtualProtect.c

```c
#include <windows.h>
#include <stdio.h>

DWORD WINAPI printMessage(LPVOID lpParam){
    printf("Hello World\n");

    return 0;
}

int main(){
    
    HANDLE threadHandle=CreateThread(NULL,0,printMessage,NULL,0 , NULL);

    if (threadHandle==NULL){
        printf("Error al rear el hilo\n");
        return 1;
    }
    WaitForSingleObject(threadHandle,INFINITE);
    CloseHandle(threadHandle);

    return 0;
}
```


```c
DWORD oldProtect;
```
Se declara una variable `oldProtect` de tipo DWORD (un tipo de dato definido por Windows para representar un entero sin signo de 32 bits). Esta variable almacenará los permisos de protección antiguos cuando se cambien con VirtualProtect.

Asignación de memoria con VirtualAlloc:

```c
void* memory = VirtualAlloc(NULL, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READONLY);
```

Este bloque asigna 1024 bytes (1 KB) de memoria usando VirtualAlloc, como en el ejemplo anterior. Sin embargo, hay una diferencia clave:

PAGE_READONLY: Este valor indica que la memoria asignada inicialmente solo tendrá permisos de lectura. Esto significa que no se podrá escribir en esta memoria después de asignarla.

Cambio de protección con `VirtualProtect`:

```c
if (VirtualProtect(memory, 1024, PAGE_READWRITE, &oldProtect)) {
    printf("Protección cambiada a lectura-escritura\n");
} else {
    printf("Error al cambiar protección\n");
}
```

Aquí se utiliza la función VirtualProtect para cambiar los permisos de protección de la memoria asignada. Los parámetros son:

memory: La dirección de la memoria cuya protección se va a cambiar.
1024: El tamaño de la región de memoria (1 KB) cuyos permisos se van a modificar.
PAGE_READWRITE: Este valor indica que se cambia la protección a lectura y escritura.
&oldProtect: Un puntero a la variable que almacenará los permisos de protección anteriores. Esto es útil si se quiere restaurar los permisos más tarde.


### 3.Copiar-memoria-RtlMoveMemory.c

```c
#include <windows.h>
#include <stdio.h>
#include <string.h>

int main(){
    char src[100]="Este es el contenido original";
    char dst[100];

    RtlMoveMemory(dst,src,strlen(src) + 1);

    printf("Original: %s\n",src);
    printf("Copiado: %s\n",dst);

    return 0;
}
```

Declaración de variables:

```c
char src[100] = "Este es el contenido original";
char dst[100];

```

src: Se declara un array de caracteres con espacio para 100 caracteres y se inicializa con la cadena "Este es el contenido original".
dst: Se declara otro array de caracteres con el mismo tamaño (100), pero no se inicializa. Este será el destino de la copia de memoria.

Copiar memoria con RtlMoveMemory:

```c
RtlMoveMemory(dst, src, strlen(src) + 1);
```

RtlMoveMemory es una función de Windows que copia una cantidad específica de bytes desde un área de memoria fuente (src) a un área de memoria destino (dst).
Parámetros:
dst: Destino de la copia (donde se van a copiar los datos).
src: Fuente de los datos (lo que se va a copiar).
strlen(src) + 1: Longitud de la cadena fuente más uno para incluir el carácter nulo (\0) que marca el final de una cadena en C.


### 4.Crear_Hilo.c

```c
#include <windows.h>
#include <stdio.h>

DWORD WINAPI printMessage(LPVOID lpParam){
    printf("Hello World\n");

    return 0;
}

int main(){
    
    HANDLE threadHandle=CreateThread(NULL,0,printMessage,NULL,0 , NULL);

    if (threadHandle==NULL){
        printf("Error al rear el hilo\n");
        return 1;
    }
    WaitForSingleObject(threadHandle,INFINITE);
    CloseHandle(threadHandle);

    return 0;
}
```

Definir la función del hilo:

```c
DWORD WINAPI printMessage(LPVOID lpParam){
    printf("Hello World\n");
    return 0;
}

```

printMessage: Es la función que se ejecutará en el nuevo hilo. La convención WINAPI indica que es una función compatible con la API de Windows.
Parámetros:
LPVOID lpParam: Es un puntero a datos que pueden pasarse al hilo. En este caso, no se utiliza, por lo que se ignora.
Retorno: La función devuelve un valor de tipo DWORD, que es el código de salida del hilo. Aquí simplemente se retorna 0, lo que indica que el hilo finalizó correctamente.

Función main:

```c
int main(){
    HANDLE threadHandle = CreateThread(NULL, 0, printMessage, NULL, 0, NULL);

```

CreateThread: Esta función crea un nuevo hilo.
Parámetros:
NULL: No se pasa ningún atributo de seguridad, por lo que se utilizan los valores predeterminados.
0: El tamaño de la pila del hilo. Al pasar 0, se utiliza el tamaño predeterminado del sistema.
printMessage: La función que ejecutará el hilo.
NULL: No se pasan parámetros adicionales a la función del hilo.
0: El hilo comienza a ejecutarse inmediatamente.
NULL: No se necesita el ID del hilo, por lo que se pasa NULL.
Retorno: CreateThread devuelve un manejador del hilo (HANDLE). Si falla, devuelve NULL.

Esperar a que el hilo termine:

```c
  WaitForSingleObject(threadHandle, INFINITE);
```

WaitForSingleObject: Esta función se utiliza para esperar hasta que el hilo especificado termine.
Parámetros:
threadHandle: El manejador del hilo que queremos esperar.
INFINITE: Espera indefinidamente hasta que el hilo finalice.


Cerrar el manejador del hilo:

```c
    CloseHandle(threadHandle);
```

Después de que el hilo termina, es importante liberar los recursos asociados con él, por lo que se cierra el manejador usando CloseHandle.


### 5.Modificar_Payload-MessageBox.c

```c
#include <windows.h>
#include <stdio.h>

int main(){
    
    MessageBox(NULL,"Payload","Payload Ejecutado",MB_OK);
    return 0;
}
```

Mostrar un cuadro de mensaje (MessageBox):

```c
MessageBox(NULL, "Payload", "Payload Ejecutado", MB_OK);
```

MessageBox: Es una función de la API de Windows que muestra un cuadro de diálogo que contiene un mensaje, un título y uno o más botones, dependiendo de los parámetros.

Parámetros:
NULL: El primer parámetro indica el manejador de la ventana padre. Al pasar NULL, se indica que el cuadro de mensaje no está asociado con ninguna ventana específica.
"Payload": El segundo parámetro es el mensaje que se mostrará en el cuadro de mensaje.
"Payload Ejecutado": El tercer parámetro es el título de la ventana del cuadro de mensaje.
MB_OK: Este cuarto parámetro indica el tipo de botón que se mostrará. MB_OK muestra solo un botón "OK" en el cuadro de mensaje.
